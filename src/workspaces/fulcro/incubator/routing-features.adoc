= Routing Features

The routing system under design has the following feature requirements:

Composition:: Routers should compose in a flexible manner that includes the easy ability to refactor the application and restructure.

URI <-> Routes should be interpreted by the router UI structure itself::  Reshaping the URI can be done by optional functions that sit in-between browser URI and code.

There should be a way to run pessimistic operations *before* moving to a given route::  This should be a chain of operations that is derived from the target routers themselves (or their children?).

UI Code should be able to prevent a route change::  E.g. say there are unsaved changes on some page in a tree: a UI component must be able to "hook into" the routing system in order to prevent changes. NOTE: This is not a feature of the *routers*, but a feature of the *content* under a router.  This can be modelled as a global concern, since routing (esp. that involves URI changes) is a global concern.

Code Splitting:: A complete routing system for SPAs should make it easy to do code splitting at particular routes so that an initial load of the application need not load the code for every feature.

== Routers

Dynamic routing in Fulcro can be easily facilitated by leveraging the UI query, which is a tool of composition that is always guaranteed to be present in a properly-structured application.  Each component's state will be normalized, and the class and relative UI position can be determined by examining the current UI query.

Take the following UI layout:

[ditaa, image=boo.jpg]
....

   +-------+
   |Root   |
   +---+---+
       |
   +---+---+
   |Router |  (acts like a "/" in a URI)
   +-+---+-+
     |   |
     |   +------+
     |          | D
 +---+---+ +----+----+
 |User[n]| |Settings |   Router targets (route segments act like URI elements)
 +-------+ +----+----+   /user/n or /settings (initial "/" derived from UI path)
                |
           +----+--+
           |Router | (acts like a "/")
           +-+--+--+
             |  |
    +--------+  |
  D |           |
 +--+----+ +----+----+
 |Pane 1 | |Pane 2   |  Router targets (segments acts like URI elements)
 +-------+ +---------+  /settings/pane1 or /settings/pane2 ("/settings" derived from UI path)
....

The routers in this system can easily be autogenerated by a macro that is given nothing more than the classes of the components that are the targets of routing (i.e. User, Settings, etc.).  The macro can simply compose them together into a component that has a dynamic query whose "current route" points to the first class listed (marked with `D` in the diagram).  If the given router is to be shown on initial startup, then these default routing targets must be singletons (have an ident that does not depend on their props).

This delegates the novelty of routing targets to the *target itself*.  Interestingly, this is quite convenient for composition and refactoring.  The router is not programmed with any foreknowledge of the routing novelty of a target...only it's symbolic name!

```
(defrouter RootRouter Settings User)
(def ui-root-router (prim/factory RootRouter))

(defrouter SettingsRouter Pane1 Pane2)
(def ui-settings-router (prim/factory SettingsRouter))
```

The use of query scanning and dynamic queries for routing mean that you can easily add or remove a sub-route just by moving the symbol to a different router.

Such routers are simple Fulcro components, and can be composed into the UI just like any other components. The initial state parameters passed to such a router are *forwarded* to the *default* (first listed) router target (if it has initial state).

== Routing Targets

Most of the novelty about routes can now be encoded into normal components with simple declarations (will write a helper macro soon).  The routing novelty is specified by two protocols (`will-leave` functionality is not implemented yet, but can be declared):

```
(ns app
  (require
    ...
    [fulcro.incubator.dynamic-routing :as dr :refer [defrouter]]))

(defsc X [this props]
 {:protocols [static dr/RouteTarget
              (route-segment [_] ...path segments...)
              (will-enter [_ reconciler route-params] ...defer or immediate...)
              dr/RouteLifecycle
              (will-leave [this props] ...true or false...)]}
```

`route-segment`:: A (relative) path segment that this component can "consume" from an incoming route. This is purely static data, and the argument is the class itself (to satisfy protocols). The current composition of routing targets in the UI determines the overall "absolute" path of a route. Each `router` in the UI should be thought of as a stand-in for a "/" in an HTML5 URI path.
`will-enter`:: A notification that this route target should be shown.  Can return a value indicating a desire to do so immediately, or after some I/O. This method is called *before* the component is on-screen, so it cannot receive a react component instance.  It is instead passed the reconciler and router parameters which can be used to do things like issues loads and run mutations.
`will-leave`:: A method that can prevent a route change that causes this component to leave the screen. This is called on the instance, so `this` and `props` are available.

=== Route Segments and Changing Routes

UI Composition determines the available routes, and each route target must declare what part of the current "route" they can consume.  The declaration is a vector of literal strings and keywords:

```
["user" :user-id]
```

Strings in the route segment *MUST* exactly match an incoming path prefix or the route does not match.  The keyword parameters are *route parameters*, and *capture* the incoming route element *as a string* (this ensures that URI's will work just as well as code-based paths that might contain other data types).

Path segments compose in the UI. In our earlier diagram the `Settings` component might have the route segments: `["settings"]` and the `User` component `["user" :user-id]".  The `Pane2` component might list `["pane1"]`.  Now, since the pane 1 component is currently *nested* as a target of the router underneath the settings component, we can derive that the *full path* to Pane 1 in *this* particular UI layout is `["settings" "pane1"]`. This is the next critical step in our composition:  Routers in a tree look for targets that can consume *what remains* of the path after parent targets have *consumed* the portion that matched those route segments.

Hopefully you can see how this directly matches the necessary logic for HTML5 URI routing.  The following URIs are trivial to convert between the two forms:

```
"/settings/pane1"  <==>  ["settings" "pane1"]
"/user/1"          <==>  ["user" "1"]
```

This mechanism makes routing as simple as "read the URI, split the string, and call a function".

The function to cause a route change is:

```
(dr/change-route this ["user" "1"])
```

and it *always* starts from the root of your application and causes a full update of the correct route.

NOTE: This library will not have any code that connects HTML5 routing events to UI routing.  That is a relatively simple exercise and there are plenty of libraries that can help with the task.  The logic of transforming a URI to the correct vector and calling a function is trivial.

TODO: We need a `relative-change-route` that can be run from some layer. E.g. let a UI component under "settings" switch to "pane1" without having to start from root. This would also aid with composition and refactoring, since the "relative path" instructions would "self-heal" under refactoring.

TODO: Still need a function that gives back the "current route" as a vector. It's just a query scan, but it isn't written yet.

=== Aborting a Route Change

NOTE: Not yet implemented. Probably needs more parameters, such as the "route being attempted" in case the component wants to save it for a later "continue" operation (e.g. "Are You Sure?", "Yes").

The `will-leave` method may return false.  If it does so AND is active on the screen then it prevents the entire route change.  This allows a screen to hold up routing in case edits would be lost, etc.  Of course you should do something in this method to change the UI so the user knows what is going on.  This is a non-static method and receives the component, so it can `transact!`, etc.

=== Deferred Routing

There are times when you want to delay a route change based on some I/O operation, like a load or mutation.  A router can do this via the return value of the `will-enter` method:

`(df/route-deferred ident)`:: Record the fact that the route wants to change, but don't actually apply it. The ident passed should be the ident of the component that should be routed to (of the current type).
`(df/route-immediate ident)`:: Immediately apply the route for this router.

Of course you should not do immediate routing if the ident you're returning does not point to something that already exists in the database.  Perhaps you need to load it.

Pending routes can be completed by calling the `dr/target-ready` mutation with a `target` parameter that matches the `ident` you passed with `route-deferred`.  For example, say you wanted to load a user before routing to them:

```
(defsc User [this props]
  {:query     [:user/id :user/name]
   :ident     [:user/id :user/id]
   :protocols [static dr/RouteTarget
               (route-segment [_] ["user" :user-id])
               (will-enter [_ reconciler {:keys [user-id]}]
                 (let [id 1]
                   (df/load reconciler [:user/id id] User {:post-mutation        `dr/target-ready
                                                           :post-mutation-params {:target [:user/id id]}})
                   (dr/route-deferred [:user/id id])))]}
  (dom/div ...))
```

Note that the route parameters come in via a map keyed by the keyword in your `route-segment`. Remember that the value of these is guaranteed to be a string, so be sure you coerce them if you need them to be a different type.

IMPORTANT: The `will-enter` method *MUST* return the value of a call to either `route-immediate` or `route-deferred`.

==== Code Splitting

The route defer mechanism should be sufficient to implement code splitting, where the routing target is the "join point" for the dynamic code.  Basically the component would not include the code-split child in the query or UI initially, but could trigger a code load and defer routing (storing the ident in a place where the loaded code could trigger the completion of the route, and a dynamic query change of the original component to point to the newly loaded component).

Something like:

```
(defsc CodeSplit [this props]
  {:ident     (fn [] [:CodeSplit 1])     ; constant ident
   :query     [{:loaded-component ['*]}] ; a placeholder join. Set dynamically after code load
   :initial-state {:loaded-component {}} ; placeholder state data
   :protocols [static dr/RouteTarget
               (will-enter [_ reconciler _]
                 ;; trigger a code load
                 (loader/load :some-module)
                 ;; The loaded code would use this data (at some well-known location)
                 ;; to figure out how to set the query of CodeSplit, join up some data in app
                 ;; state, and run the target-ready mutation:
                 (swap! common-ns/pending-route-atom assoc :some-module {:reconciler reconciler
                                                                         :class CodeSplit})
                 (dr/route-deferred [:CodeSplit 1]))]}
   ...
   ;; The DOM can use query introspection to find the component that ended up in the query, make
   ;; a factory for it, and render it.  See how the dr/current-route-class macro for an example
   ;; of how to do that. something like:
   ;; (let [factory (some-> this prim/get-query prim/query->ast1 :component prim/factory)]
   ;;   (when factory (factory (:loaded-component props))))
```

TODO: A macro and small lib that wraps this concern.

TODO: A dynamic code load means that there may be path segments in the current route that cannot be evaluated until the code load is complete.  It may be necessary to "re-trigger" a route after a code load to ensure that the path segments have been fully evaluated.  This would be a good use of a relative change route function, which could be run on the newly-loaded sub-components with the remaining path.  I think it should be relatively easy to just defer the rest of the sub-routing until the given route is resolved...that is probably best, as it doesn't require user intervention. The problem with that is that sub-routes may also want to queue I/O, and getting it all queued at once might be preferable to delaying. We could support something like `route-blocked` which would resume routing after the ready signal, and allow the `route-deferred` to continue down the route resolving sub-paths and queuing I/O.  Undecided.

== TODO: Macro for Route Targets

I'm thinking that the macro for this would be something like:

```
(defsc-router-target Pane2 [this props]
  {... normal defsc stuff...
   :route-segment ["pane2"]
   :will-enter (fn [c reconciler route-params] ...)
   :will-leave (fn [this props] true)
  }
  ...normal body...)
```

with only `:route-segment` required.

`:will-leave`:: defaults to returning `true`.

`:will-enter`:: Must return an immediate or deferred route instruction. The default is an immediate route based on the component's `(ident component-class {})`, which is only sane if the component has a singleton database instance (constant ident).

== Full Example

The workspaces source contains a full working example of this routing system in
https://github.com/fulcrologic/fulcro-incubator/blob/feature/routing-experiment/src/workspaces/fulcro/incubator/routing_ws.cljs
