= Routing Features

The routing system under design has the following feature requirements:

Composition:: Routers should compose in a flexible manner that includes the easy ability to refactor the application and restructure.

URI <-> Routes should be interpreted by the router UI structure itself::  Reshaping the URI can be done by optional functions that sit in-between browser URI and code.

There should be a way to run pessimistic operations *before* moving to a given route::  This should be a chain of operations that is derived from the target routers themselves (or their children?).

UI Code should be able to prevent a route change::  E.g. say there are unsaved changes on some page in a tree: a UI component must be able to "hook into" the routing system in order to prevent changes. NOTE: This is not a feature of the *routers*, but a feature of the *content* under a router.  This can be modelled as a global concern, since routing (esp. that involves URI changes) is a global concern.

== Routers

Dynamic routing in Fulcro can be easily facilitated by leveraging the UI query, which is a tool of composition that is always guaranteed to be present in a properly-structured application.  Each component's state will be normalized, and the class and relative UI position can be determined by examining the current UI query.

Take the following UI layout:

[ditaa, image=boo.jpg]
....

   +-------+
   |Root   |
   +---+---+
       |
   +---+---+
   |Router |
   +-+---+-+
     |   |
     |   +------+
     |          | D
 +---+---+ +----+----+
 |User[n]| |Settings |   Router targets
 +-------+ +----+----+
                |
           +----+--+
           |Router |
           +-+--+--+
             |  |
    +--------+  |
  D |           |
 +--+----+ +----+----+
 |Pane 1 | |Pane 2   |  Router targets
 +-------+ +---------+
....

The routers in this system can easily be autogenerated by a macro that is given nothing more than the classes of the components that are the targets of routing (i.e. User, Settings, etc.).  The macro can simply compose them together into a component that has a dynamic query whose "current route" points to the first class listed (marked with `D` in the diagram).  If the given router is to be shown on initial startup, then these default routing targets must be singletons (have an ident that does not depend on their props).

This delegates the novelty of routing targets to the *target itself*.  Interestingly, this is quite convenient for composition and refactoring.  The router is not programmed with any foreknowledge of the routing novelty in a target...only it's symbolic name!

```
(defrouter RootRouter Settings User)
(def ui-root-router (prim/factory RootRouter))

(defrouter SettingsRouter Pane1 Pane2)
(def ui-settings-router (prim/factory SettingsRouter))
```

The use of query scanning and dynamic queries for routing mean that you can easily add or remove a sub-route just by moving the symbol to a different router.

== Routing Targets

Most of the novelty about routes can now be encoded into normal components with simple declarations (will write a helper macro soon).  The routing novelty is specified by two protocols (`will-leave` is not implemented yet, but can be declared):

```
(ns app
  (require
    ...
    [fulcro.incubator.dynamic-routing :as dr :refer [defrouter]]))

(defsc X [this props]
 {:protocols [static dr/RouteTarget
              (route-segment [_] ...path segments...)
              (will-enter [_ reconciler route-params] ...defer or immediate...)
              dr/RouteLifecycle
              (will-leave [this props] ...true or false...)]}
```

=== Route Segments and Changing Routes

UI Composition determines the available routes, and each route target must declare what part of the current "route" they can consume.  The declaration is a vector of literal strings and keywords:

```
["user" :user-id]
```

Strings in the route segment *MUST* exactly match an incoming path prefix or the route does not match.  The keyword parameters are *route parameters*, and *capture* the incoming route element *as a string* (this ensures that URI's will work just as well as code-based paths that might contain other data types).

Path segments compose in the UI. In our earlier diagram the `Settings` component might have the route segments: `["settings"]` and the `User` component `["user" :user-id]".  The `Pane2` component might list `["pane1"]`.  Now, since the pane 1 component is currently *nested* as a target of the router underneath the settings component, we can derive that the *full path* to Pane 1 in *this* particular UI layout is `["settings" "pane1"]`. This is the next critical step in our composition:  Routers in a tree look for targets that can consume *what remains* of the path after parent targets have *consumed* the portion that matched those route segments.

Hopefully you can see how this directly matches the necessary logic for HTML5 URI routing.  The following URIs are trivial to convert between the two forms:

```
"/settings/pane1"  <==>  ["settings" "pane1"]
"/user/1"          <==>  ["user" "1"]
```

This mechanism makes routing as simple as "read the URI, split the string, and call a function".

The function to cause a route change is:

```
(dr/change-route this ["user" "1"])
```

and it *always* starts from the root of your application and causes a full update of the correct route.

TODO: We could also use a relative change route that could be run from some layer...easy enough to write.

TODO: Still need a function that gives back the "current route" as a vector. It's just a query scan, but it isn't written yet.

=== Aborting a Route Change

NOTE: Not yet implemented. Probably needs more parameters, such as the route being attmepted in case the component wants to save it for a later "continue" to the route (e.g. Are You Sure? Yes).

The `will-leave` method may return false.  If it does so when it is active on the screen, it prevents route changes.  This allows a screen to hold up routing in case edits would be lost, etc.  Of course you should do something in this method to change the UI so the user knows what is going on.  This is a non-static method, and receives the component, so it can `transact!`, etc.

=== Deferred Routing

There are times when you want to delay a route change based on some I/O operation, like a load or mutation.  A router can do this via the return value of the `will-enter` method:

`(df/route-deferred ident)`:: Record the fact that the route wants to change, but don't actually apply it. The ident passed should be the ident of the component that should be routed to (of the current type).
`(df/route-immediate ident)`:: Immediately apply the route for this router.

Of course you should not do immediate routing if the ident you're returning does not point to something that already exists in the database.  Perhaps you need to load it.

Pending routes can be completed by calling the `dr/target-ready` mutation with a `target` parameter that matches the `ident` you passed with `route-deferred`.  For example, say you wanted to load a user before routing to them:

```
(defsc User [this props]
  {:query     [:user/id :user/name]
   :ident     [:user/id :user/id]
   :protocols [static dr/RouteTarget
               (route-segment [_] ["user" :user-id])
               (will-enter [_ reconciler {:keys [user-id]}]
                 (let [id 1]
                   (df/load reconciler [:user/id id] User {:post-mutation        `dr/target-ready
                                                           :post-mutation-params {:target [:user/id id]}})
                   (dr/route-deferred [:user/id id])))]}
  (dom/div ...))
```

Note that the route parameters come in via a map keyed by the keyword in your `route-segment`. Remember that the value of these is guaranteed to be a string, so be sure you coerce them if you need them to be a different type.

==== Using Deferred Loading for Code Splitting

The above defer mechanism should be sufficient to implement code splitting, where the routing target is the "join point" for the dynamic code.  Basically the component would not include the code-split child in the query or UI initially, but could trigger a code load and defer routing (storing the ident in a place where the loaded code could trigger the completion of the route, and a dynamic query change of the original component to point to the newly loaded component).

TODO: A macro and small lib that wraps this concern.

== Full Example

The workspaces source contains a full working example of this routing system in
https://github.com/fulcrologic/fulcro-incubator/blob/feature/routing-experiment/src/workspaces/fulcro/incubator/routing_ws.cljs
